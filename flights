(ns flights.carbon)

;; Avg 12 liters per KM
(def avg-fuel-usage-per-km 12)

(def avg-fuel-usage-takeoff-landing 1100)

(def avg-no-passengers 300)

;; Source - https://www.statista.com/statistics/986460/co2-emissions-per-cap-eu/#:~:text=Greenhouse%20gas%20emissions%20per%20capita%20in%20the%20European%20Union%201990%2D2021&text=Per%20capita%20greenhouse%20gas%20(GHG,tons%20of%20carbon%20dioxide%20equivalent.
(def avg-person-annual-emissions 7.77e3)

;; Source - https://www.umweltbundesamt.de/daten/klima/treibhausgas-emissionen-in-der-europaeischen-union#hauptverursacher
(def recommended-annual-avg 0.6e3)

(defn- total-co2-emitted
  "The '3.16' is the 'emissions factor'"
  [distance]
  (*
   (+ (* distance avg-fuel-usage-per-km) ;; this should prob be adjusted for shorted distance after takeoff/landing
      avg-fuel-usage-takeoff-landing)
   3.16))

(defn- personal-co2-contribution [total-c02]
  (/ total-c02 avg-no-passengers))


(defn personal-co2-emissions [distance]
  (-> distance
      total-co2-emitted
      personal-co2-contribution))

(ns flights.message
  (:require [clojure.string :as str]
            [flights.carbon :as carbon]))

;; Formatting for the main printed outputs

(defn- hours->hr-min [hours]
  (let [h (int hours)
        mins  (int (* (mod hours 1) 60))]
    (str h (if (= 1 h) " hour, " " hours, ")
         mins (if (= 1 mins) " minute" " minutes"))))

(defn- airport-location-str [{:keys [name city country]}]
  (str (str/capitalize name)
       " Airport in "
       (str/capitalize city)
       ", "
       (str/capitalize country)))

(defn flight-time-msg [{:keys [flight-time]}]
  (let [[lwr upr] (map hours->hr-min flight-time)]
    (str "Estimated Flight Time: Between " lwr
         " and "
         upr)))

(defn oirgin-and-destination-msg [{:keys [origin destination]}]
  (str/join "\n"
            [(str "Origin: " (airport-location-str origin))
             (str "Destination: " (airport-location-str destination))]))

(defn city-names-msg [{:keys [country cities]}]
  (str "The following cities have airports in " country
       ":\n- "
       (str/join "\n- " cities)))

(defn airport-names-msg [{:keys [city airports]}]
  (str "The following airports are in " city
       ":\n- "
       (str/join "\n- " airports)))


(def bar-symbol (char 9632))

(defn bar-string [percentage]
  (let [len (* 50 (/ percentage 100))]
    (str "[" (str/join (repeat len bar-symbol)) "]")))

(def co2-annual-avg-bar (str (bar-string 100)
                             " EU Person Annual Avg: "
                             (int carbon/avg-person-annual-emissions)
                             " kg"))

(defn personal-co2-usage-bar [co2-personal co2-percentage]
  (str
   (bar-string co2-percentage)
   " Carbon cost: " co2-personal " kg / "
   co2-percentage "% of annual EU avg"))


(defn recommended-co2-bar []
  (str
   (bar-string (* 100 (/ carbon/recommended-annual-avg carbon/avg-person-annual-emissions)))
   " Recommended annual avg: " carbon/recommended-annual-avg
   " kg"))

(defn carbon-msg [{:keys [co2-personal co2-percentage-annual-avg]}]
  (str/join "\n"
            [(personal-co2-usage-bar co2-personal co2-percentage-annual-avg)
             (recommended-co2-bar)
             co2-annual-avg-bar]))
(ns flights.fuzzy
  (:require [clojure.string :as str]
            [clojure.set :as set]))

;; Functions taken from - https://github.com/Yomguithereal/clj-fuzzy

(defn n-grams
  "Lazily compute the n-grams of a sequence."
  [n s]
  (partition n 1 s))

(defn- letter-sets
  [n string]
  (set (n-grams n (-> (str/replace string #"\s+" "")
                      (str/upper-case)))))
;; Main functions
(defn coefficient
  "Compute the Dice coefficient between two [strings]."
  [string1 string2 & {:keys [n] :or {n 2}}]
  (cond (= string1 string2) 1.0
        (and (< (count string1) 2)
             (< (count string2) 2)) 0.0
        :else (let [p1 (letter-sets n string1)
                    p2 (letter-sets n string2)
                    sum (+ (count p1) (count p2))]
                (/ (* 2.0 (count (set/intersection p1 p2)))
                   sum))))
(ns honeysql.util)

(defmacro defalias [sym var-sym]
  `(let [v# (var ~var-sym)]
     (intern *ns* (with-meta (quote ~sym) (meta v#)) @v#)))(ns honeysql.helpers
  (:refer-clojure :exclude [update])
  #?(:cljs (:require-macros [honeysql.helpers :refer [defhelper]])))

(defmulti build-clause (fn [name & args]
                         name))

(defmethod build-clause :default [_ m & args]
  m)

(defn plain-map? [m]
  (and
    (map? m)
    (not (record? m))))

#?(:clj
    (defmacro defhelper [helper arglist & more]
      (when-not (vector? arglist)
        (throw #?(:clj (IllegalArgumentException. "arglist must be a vector")
                  :cljs (js/Error. "arglist must be a vector"))))
      (when-not (= (count arglist) 2)
        (throw #?(:clj (IllegalArgumentException. "arglist must have two entries, map and varargs")
                  :cljs (js/Error. "arglist must have two entries, map and varargs"))))

      (let [kw (keyword (name helper))
            [m-arg varargs] arglist]
        `(do
           (defmethod build-clause ~kw ~['_ m-arg varargs] ~@more)
           (defn ~helper [& args#]
             (let [[m# args#] (if (plain-map? (first args#))
                                [(first args#) (rest args#)]
                                [{} args#])]
               (build-clause ~kw m# args#)))

           ;; maintain the original arglist instead of getting
           ;; ([& args__6880__auto__])
           (alter-meta!
            (var ~helper)
            assoc
            :arglists
            '(~['& varargs]
              ~[m-arg '& varargs]))))))

(defn collify [x]
  (if (coll? x) x [x]))

(defhelper select [m fields]
  (assoc m :select (collify fields)))

(defhelper merge-select [m fields]
  (update-in m [:select] concat (collify fields)))

(defhelper un-select [m fields]
  (update-in m [:select] #(remove (set (collify fields)) %)))

(defhelper from [m tables]
  (assoc m :from (collify tables)))

(defhelper merge-from [m tables]
  (update-in m [:from] concat (collify tables)))

(defmethod build-clause :where [_ m pred]
  (if (nil? pred)
    m
    (assoc m :where pred)))

(defn- prep-where [args]
  (let [[m preds] (if (map? (first args))
                    [(first args) (rest args)]
                    [{} args])
        [logic-op preds] (if (keyword? (first preds))
                           [(first preds) (rest preds)]
                           [:and preds])
        preds (remove nil? preds)
        pred (if (>= 1 (count preds))
               (first preds)
               (into [logic-op] preds))]
    [m pred logic-op]))

(defn where [& args]
  (let [[m pred] (prep-where args)]
    (if (nil? pred)
      m
      (assoc m :where pred))))

(defmethod build-clause :merge-where [_ m pred]
  (if (nil? pred)
    m
    (assoc m :where (if (not (nil? (:where m)))
                      [:and (:where m) pred]
                      pred))))

(defn merge-where [& args]
  (let [[m pred logic-op] (prep-where args)]
    (if (nil? pred)
      m
      (assoc m :where (if (not (nil? (:where m)))
                        [logic-op (:where m) pred]
                        pred)))))

(defhelper join [m clauses]
  (assoc m :join clauses))

(defhelper merge-join [m clauses]
  (update-in m [:join] concat clauses))

(defhelper left-join [m clauses]
  (assoc m :left-join clauses))

(defhelper merge-left-join [m clauses]
  (update-in m [:left-join] concat clauses))

(defhelper right-join [m clauses]
  (assoc m :right-join clauses))

(defhelper merge-right-join [m clauses]
  (update-in m [:right-join] concat clauses))

(defhelper full-join [m clauses]
  (assoc m :full-join clauses))

(defhelper merge-full-join [m clauses]
  (update-in m [:full-join] concat clauses))

(defhelper cross-join [m clauses]
  (assoc m :cross-join clauses))

(defhelper merge-cross-join [m clauses]
  (update-in m [:cross-join] concat clauses))

(defmethod build-clause :group-by [_ m fields]
  (assoc m :group-by (collify fields)))

(defn group [& args]
  (let [[m fields] (if (map? (first args))
                     [(first args) (rest args)]
                     [{} args])]
    (build-clause :group-by m fields)))

(defhelper merge-group-by [m fields]
  (update-in m [:group-by] concat (collify fields)))

(defmethod build-clause :having [_ m pred]
  (if (nil? pred)
    m
    (assoc m :having pred)))

(defn having [& args]
  (let [[m pred] (prep-where args)]
    (if (nil? pred)
      m
      (assoc m :having pred))))

(defmethod build-clause :merge-having [_ m pred]
  (if (nil? pred)
    m
    (assoc m :having (if (not (nil? (:having m)))
                       [:and (:having m) pred]
                       pred))))

(defn merge-having [& args]
  (let [[m pred logic-op] (prep-where args)]
    (if (nil? pred)
      m
      (assoc m :having (if (not (nil? (:having m)))
                         [logic-op (:having m) pred]
                         pred)))))

(defhelper order-by [m fields]
  (assoc m :order-by (collify fields)))

(defhelper merge-order-by [m fields]
  (update-in m [:order-by] concat (collify fields)))

(defhelper limit [m l]
  (if (nil? l)
    m
    (assoc m :limit (if (coll? l) (first l) l))))

(defhelper offset [m o]
  (if (nil? o)
    m
    (assoc m :offset (if (coll? o) (first o) o))))

(defhelper lock [m lock]
  (cond-> m
    lock
    (assoc :lock lock)))

(defhelper modifiers [m ms]
  (if (nil? ms)
    m
    (assoc m :modifiers (collify ms))))

(defhelper merge-modifiers [m ms]
  (if (nil? ms)
    m
    (update-in m [:modifiers] concat (collify ms))))

(defmethod build-clause :insert-into [_ m table]
  (assoc m :insert-into table))

(defn insert-into
  ([table] (insert-into nil table))
  ([m table] (build-clause :insert-into m table)))

(defn- check-varargs
  "Called for helpers that require unrolled arguments to catch the mistake
  of passing a collection as a single argument."
  [helper args]
  (when (and (coll? args) (= 1 (count args)) (coll? (first args)))
    (let [msg (str (name helper) " takes varargs, not a single collection")]
      (throw #?(:clj (IllegalArgumentException. msg)
                :cljs (js/Error. msg))))))

(defmethod build-clause :columns [_ m fields]
  (assoc m :columns (collify fields)))

(defn columns [& args]
  (let [[m fields] (if (map? (first args))
                     [(first args) (rest args)]
                     [{} args])]
    (check-varargs :columns fields)
    (build-clause :columns m fields)))

(defmethod build-clause :merge-columns [_ m fields]
  (update-in m [:columns] concat (collify fields)))

(defn merge-columns [& args]
  (let [[m fields] (if (map? (first args))
                     [(first args) (rest args)]
                     [{} args])]
    (check-varargs :merge-columns fields)
    (build-clause :merge-columns m fields)))

(defhelper composite [m vs]
  (if (nil? vs)
    m
    (assoc m :composite (collify vs))))

(defmethod build-clause :values [_ m vs]
  (assoc m :values vs))

(defn values
  ([vs] (values nil vs))
  ([m vs] (build-clause :values m vs)))

(defmethod build-clause :merge-values [_ m vs]
  (update-in m [:values] concat vs))

(defn merge-values
  ([vs] (merge-values nil vs))
  ([m vs] (build-clause :merge-values m vs)))

(defmethod build-clause :query-values [_ m vs]
  (assoc m :query-values vs))

(defn query-values
  ([vs] (values nil vs))
  ([m vs] (build-clause :query-values m vs)))

(defmethod build-clause :update [_ m table]
  (assoc m :update table))

(defn update
  ([table] (update nil table))
  ([m table] (build-clause :update m table)))

(defmethod build-clause :set [_ m values]
  (assoc m :set values))

;; short for sql set, to avoid name collision with clojure.core/set
(defn sset
  ([vs] (sset nil vs))
  ([m vs] (build-clause :set m vs)))

(defmethod build-clause :set0 [_ m values]
  (assoc m :set0 values))

;; set with lower priority (before from)
(defn set0
  ([vs] (set0 nil vs))
  ([m vs] (build-clause :set0 m vs)))

(defmethod build-clause :set [_ m values]
  (assoc m :set values))

;; set with higher priority (after join)
(defn set1
  ([vs] (set1 nil vs))
  ([m vs] (build-clause :set1 m vs)))

(defmethod build-clause :delete-from [_ m table]
  (assoc m :delete-from table))

(defn delete-from
  ([table] (delete-from nil table))
  ([m table] (build-clause :delete-from m table)))

(defmethod build-clause :delete [_ m tables]
  (assoc m :delete tables))

(defn delete
  ([tables] (delete nil tables))
  ([m tables] (build-clause :delete m tables)))

(defmethod build-clause :truncate [_ m table]
  (assoc m :truncate table))

(defn truncate
  ([table] (truncate nil table))
  ([m table] (build-clause :truncate m table)))

(defhelper with [m ctes]
  (assoc m :with ctes))

(defhelper with-recursive [m ctes]
  (assoc m :with-recursive ctes))

(defmethod build-clause :union [_ m maps]
  (assoc m :union maps))

(defmethod build-clause :union-all [_ m maps]
  (assoc m :union-all maps))

(defmethod build-clause :intersect [_ m maps]
  (assoc m :intersect maps))

(defmethod build-clause :except [_ m maps]
  (assoc m :except maps))
(ns honeysql.types
  (:refer-clojure :exclude [array]))

(defrecord SqlCall [name args])

(defn call
  "Represents a SQL function call. Name should be a keyword."
  [name & args]
  (SqlCall. name args))

(defn read-sql-call [form]
  ;; late bind so that we get new class on REPL reset
  (apply #?(:clj (resolve `call) :cljs call) form))

;;;;

(defrecord SqlRaw [s])

(defn raw
  "Represents a raw SQL string"
  [s]
  (SqlRaw. (if (vector? s) s (str s))))

(defn read-sql-raw [form]
  ;; late bind, as above
  (#?(:clj (resolve `raw) :cljs raw) form))

;;;;

(defrecord SqlParam [name])

(defn param
  "Represents a SQL parameter which can be filled in later"
  [name]
  (SqlParam. name))

(defn param-name [^SqlParam param]
  (.-name param))

(defn read-sql-param [form]
  ;; late bind, as above
  (#?(:clj (resolve `param) :cljs param) form))

;;;;

(defrecord SqlArray [values])

(defn array
  "Represents a SQL array."
  [values]
  (SqlArray. values))

(defn array-vals [^SqlArray a]
  (.-values a))

(defn read-sql-array [form]
  ;; late bind, as above
  (#?(:clj (resolve `array) :cljs array) form))

;;;;

(defrecord SqlInline [value])

(defprotocol Inlinable
  (inline-str [x]))

(defn inline
  "Prevents parameterization"
  [value]
  (SqlInline. value))

(defn read-sql-inline [form]
  (#?(:clj (resolve `inline) :cljs inline) form))

#?(:clj
    (do
      (defmethod print-method SqlCall [^SqlCall o ^java.io.Writer w]
        (.write w (str "#sql/call " (pr-str (into [(.-name o)] (.-args o))))))

      (defmethod print-dup SqlCall [o w]
        (print-method o w))

      (defmethod print-method SqlRaw [^SqlRaw o ^java.io.Writer w]
        (.write w (str "#sql/raw " (pr-str (.s o)))))

      (defmethod print-dup SqlRaw [o w]
        (print-method o w))

      (defmethod print-method SqlParam [^SqlParam o ^java.io.Writer w]
        (.write w (str "#sql/param " (pr-str (.name o)))))

      (defmethod print-dup SqlParam [o w]
        (print-method o w))

      (defmethod print-method SqlArray [^SqlArray a ^java.io.Writer w]
        (.write w (str "#sql/array " (pr-str (.values a)))))

      (defmethod print-dup SqlArray [a w]
        (print-method a w))

      (defmethod print-method SqlInline [^SqlInline a ^java.io.Writer w]
        (.write w (str "#sql/inline " (pr-str (.value a)))))

      (defmethod print-dup SqlInline [a w]
        (print-method a w))))
(ns honeysql.format
  (:refer-clojure :exclude [format])
  (:require [honeysql.types :as types
                            :refer [call raw param param-name inline-str
                                    #?@(:cljs [SqlCall SqlRaw SqlParam SqlArray SqlInline])]]
            [clojure.string :as string])
  #?(:clj (:import [honeysql.types SqlCall SqlRaw SqlParam SqlArray SqlInline])))

;;(set! *warn-on-reflection* true)

;;;;

(defn comma-join [s]
  (string/join ", " s))

(defn space-join [s]
  (string/join " " s))

(defn paren-wrap [x]
  (str "(" x ")"))

(def ^:dynamic *clause*
  "During formatting, *clause* is bound to :select, :from, :where, etc."
  nil)

(def ^:dynamic *params*
  "Will be bound to an atom-vector that accumulates SQL parameters across
  possibly-recursive function calls"
  nil)

(def ^:dynamic *param-names* nil)

(def ^:dynamic *param-counter* nil)

(def ^:dynamic *all-param-counter* nil)

(def ^:dynamic *input-params* nil)

(def ^:dynamic *fn-context?* false)

(def ^:dynamic *value-context?* false)

(def ^:dynamic *subquery?* false)

(def ^:dynamic *allow-dashed-names?* false)

(def ^:dynamic *allow-namespaced-names?* false)

(def ^:dynamic *namespace-as-table?* false)

(def ^:dynamic *name-transform-fn* nil)

(def ^:private quote-fns
  {:ansi #(str \" (string/replace % "\"" "\"\"") \")
   :mysql #(str \` (string/replace % "`" "``") \`)
   :sqlserver #(str \[ (string/replace % "]" "]]") \])
   :oracle #(str \" (string/replace % "\"" "\"\"") \")})


(defmulti parameterize (fn [parameterizer & args] parameterizer))

(defmethod parameterize :postgresql [_ value pname]
  (str "$" (swap! *all-param-counter* inc)))

(defmethod parameterize :jdbc [_ value pname]
  "?")

(defmethod parameterize :none [_ value pname]
  (str (last @*params*)))


(def ^:dynamic *quote-identifier-fn* nil)
(def ^:dynamic *parameterizer* nil)

(defn- undasherize [s]
  (string/replace s "-" "_"))

;; String.toUpperCase() or `string/upper-case` for that matter converts the string to uppercase for the DEFAULT
;; LOCALE. Normally this does what you'd expect but things like `inner join` get converted to `İNNER JOIN` (dot over
;; the I) when user locale is Turkish. This predictably has bad consequences for people who like their SQL queries to
;; work. The fix here is to use String.toUpperCase(Locale/US) instead which always converts things the way we'd expect.
;;
;; Use this function instead of `string/upper-case` as it will always use Locale/US.
(def ^:private ^{:arglists '([s])} upper-case
  ;; TODO - not sure if there's a JavaScript equivalent here we should be using as well
  #?(:clj (fn [^String s] (.. s toString (toUpperCase (java.util.Locale/US))))
     :cljs string/upper-case))

(defn quote-identifier [x & {:keys [style split] :or {split true}}]
  (let [name-transform-fn (cond
                            *name-transform-fn* *name-transform-fn*
                            *allow-dashed-names?* identity
                            :else undasherize)
        qf (if style
             (quote-fns style)
             *quote-identifier-fn*)
        s (cond
            (or (keyword? x) (symbol? x))
            (name-transform-fn
              (cond *namespace-as-table?*
                    (str (when-let [n (namespace x)]
                           (str n "."))
                         (name x))
                    *allow-namespaced-names?*
                    (str (when-let [n (namespace x)]
                           (str n "/"))
                         (name x))
                    :else
                    (name x)))
            (string? x) (if qf x (name-transform-fn x))
            :else (str x))]
    (if-not qf
      s
      (let [qf* #(if (= "*" %) % (qf %))]
        (if-not split
         (qf* s)
         (let [parts (string/split s #"\.")]
           (string/join "." (map qf* parts))))))))

(def infix-fns
  #{"+" "-" "*" "/" "%" "mod" "|" "&" "^"
    "and" "or" "xor"
    "in" "not in" "like" "not like" "regexp"})

(def fn-aliases
  {"is" "="
   "is-not" "<>"
   "not=" "<>"
   "!=" "<>"
   "not-in" "not in"
   "not-like" "not like"
   "regex" "regexp"})

(defprotocol ToSql
  (to-sql [x]))

(defn to-sql-value [x]
  (binding [*value-context?* (sequential? x)]
    (to-sql x)))

(defmulti fn-handler (fn [op & args] op))

(defn expand-binary-ops [op & args]
  (str "("
       (string/join " AND "
                    (for [[a b] (partition 2 1 args)]
                      (fn-handler op a b)))
       ")"))

(defmethod fn-handler :default [op & args]
  (let [args (map to-sql args)]
    (if (infix-fns op)
      (paren-wrap (string/join (str " " op " ") args))
      (str op (paren-wrap (comma-join args))))))

(defmethod fn-handler "count-distinct" [_ & args]
  (str "COUNT(DISTINCT " (comma-join (map to-sql args)) ")"))

(defmethod fn-handler "distinct-on" [_ & args]
  (str "DISTINCT ON (" (comma-join (map to-sql args)) ")"))

(defmethod fn-handler "cast" [_ field cast-to-type]
  (str "CAST" (paren-wrap (str (to-sql field)
                               " AS "
                               (to-sql cast-to-type)))))

(defmethod fn-handler "=" [_ a b & more]
  (if (seq more)
    (apply expand-binary-ops "=" a b more)
    (cond
     (nil? a) (str (to-sql-value b) " IS NULL")
     (nil? b) (str (to-sql-value a) " IS NULL")
     :else (str (to-sql-value a) " = " (to-sql-value b)))))

(defmethod fn-handler "<>" [_ a b & more]
  (if (seq more)
    (apply expand-binary-ops "<>" a b more)
    (cond
     (nil? a) (str (to-sql-value b) " IS NOT NULL")
     (nil? b) (str (to-sql-value a) " IS NOT NULL")
     :else (str (to-sql-value a) " <> " (to-sql-value b)))))

(defmethod fn-handler "<" [_ a b & more]
  (if (seq more)
    (apply expand-binary-ops "<" a b more)
    (str (to-sql-value a) " < " (to-sql-value b))))

(defmethod fn-handler "<=" [_ a b & more]
  (if (seq more)
    (apply expand-binary-ops "<=" a b more)
    (str (to-sql-value a) " <= " (to-sql-value b))))

(defmethod fn-handler ">" [_ a b & more]
  (if (seq more)
    (apply expand-binary-ops ">" a b more)
    (str (to-sql-value a) " > " (to-sql-value b))))

(defmethod fn-handler ">=" [_ a b & more]
  (if (seq more)
    (apply expand-binary-ops ">=" a b more)
    (str (to-sql-value a) " >= " (to-sql-value b))))

(defmethod fn-handler "between" [_ field lower upper]
  (str (to-sql-value field) " BETWEEN " (to-sql-value lower) " AND " (to-sql-value upper)))

;; Handles MySql's MATCH (field) AGAINST (pattern). The third argument
;; can be a set containing one or more of :boolean, :natural, or :expand.
(defmethod fn-handler "match" [_ fields pattern & [opts]]
  (str "MATCH ("
       (comma-join
        (map to-sql (if (coll? fields) fields [fields])))
       ") AGAINST ("
       (to-sql-value pattern)
       (when (seq opts)
         (str " " (space-join (for [opt opts]
                                (case opt
                                  :boolean "IN BOOLEAN MODE"
                                  :natural "IN NATURAL LANGUAGE MODE"
                                  :expand "WITH QUERY EXPANSION")))))
       ")"))

(def default-clause-priorities
  "Determines the order that clauses will be placed within generated SQL"
  {:with 20
   :with-recursive 30
   :intersect 35
   :union 40
   :union-all 45
   :except 47
   :select 50
   :insert-into 60
   :update 70
   :delete 75
   :delete-from 80
   :truncate 85
   :columns 90
   :composite 95
   :set0 100 ; low-priority set clause
   :from 110
   :join 120
   :left-join 130
   :right-join 140
   :full-join 150
   :cross-join 152
   :set 155
   :set1 156 ; high-priority set clause (synonym for :set)
   :where 160
   :group-by 170
   :having 180
   :order-by 190
   :limit 200
   :offset 210
   :lock 215
   :values 220
   :query-values 230})

(def clause-store (atom default-clause-priorities))

(defn register-clause! [clause-key priority]
  (swap! clause-store assoc clause-key priority))

(defn sort-clauses [clauses]
  (let [m @clause-store]
    (sort-by
      (fn [c]
        (m c #?(:clj Long/MAX_VALUE :cljs js/Number.MAX_VALUE)))
      clauses)))

(defn format
  "Takes a SQL map and optional input parameters and returns a vector
  of a SQL string and parameters, as expected by `next.jbc` and
  `clojure.java.jdbc`.

  Input parameters will be filled into designated spots according to
  name (if a map is provided) or by position (if a sequence is provided).

  Instead of passing parameters, you can use keyword arguments:
    :params - input parameters
    :quoting - quote style to use for identifiers; one of :ansi (PostgreSQL),
               :mysql, :sqlserver, or :oracle. Defaults to no quoting.
    :parameterizer - style of parameter naming, :postgresql,
                     :jdbc or :none. Defaults to :jdbc.
    :return-param-names - when true, returns a vector of
                          [sql-str param-values param-names]"
  [sql-map & params-or-opts]
  (let [opts (when (keyword? (first params-or-opts))
                   (apply hash-map params-or-opts))
        params (if (coll? (first params-or-opts))
                 (first params-or-opts)
                 (:params opts))]
    (binding [*params* (atom [])
              *param-counter* (atom 0)
              *all-param-counter* (atom 0)
              *param-names* (atom [])
              *input-params* (atom params)
              *quote-identifier-fn* (quote-fns (:quoting opts))
              *parameterizer* (or (:parameterizer opts) :jdbc)
              *allow-dashed-names?* (:allow-dashed-names? opts)
              *allow-namespaced-names?* (:allow-namespaced-names? opts)
              *namespace-as-table?* (:namespace-as-table? opts)]
      (let [sql-str (to-sql sql-map)]
        (if (and (seq @*params*) (not= :none (:parameterizer opts)))
          (if (:return-param-names opts)
            [sql-str @*params* @*param-names*]
            (into [sql-str] @*params*))
          [sql-str])))))

(defprotocol Parameterizable
  (to-params [value pname]))

(defn to-params-seq [s pname]
  (paren-wrap (comma-join (mapv #(to-params % pname) s))))

(defn to-params-default [value pname]
  (swap! *params* conj value)
  (swap! *param-names* conj pname)
  (parameterize *parameterizer* value pname))

(extend-protocol Parameterizable
  #?@(:clj
       [clojure.lang.Sequential

        (to-params [value pname]
          (to-params-seq value pname))])
  #?(:clj clojure.lang.IPersistentSet
     :cljs cljs.core/PersistentHashSet)
  (to-params [value pname]
    (to-params (seq value) pname))
  nil
  (to-params [value pname]
    (swap! *params* conj value)
    (swap! *param-names* conj pname)
    (parameterize *parameterizer* value pname))
  #?(:clj Object :cljs default)
  (to-params [value pname]
    #?(:clj
        (to-params-default value pname)
       :cljs
        (if (sequential? value)
          (to-params-seq value pname)
          (to-params-default value pname)))))

(defn add-param [pname pval]
  (to-params pval pname))

;; Anonymous param name -- :_1, :_2, etc.
(defn add-anon-param [pval]
  (add-param
    (keyword (str "_" (swap! *param-counter* inc)))
    pval))

(defrecord Value [v]
  ToSql
  (to-sql [_]
    (add-anon-param v)))

(defn value [x] (Value. x))

(declare -format-clause)

(defn map->sql [m]
  (let [clause-ops (sort-clauses (keys m))
        sql-str (binding [*subquery?* true
                          *fn-context?* false]
                  (space-join
                   (map (comp #(-format-clause % m) #(find m %))
                        clause-ops)))]
    (if *subquery?*
      (paren-wrap sql-str)
      sql-str)))

(declare format-predicate*)

(defn seq->sql [x]
  (cond
    *value-context?*
    ;; sequences are operators/functions
    (format-predicate* x)
    *fn-context?*
    ;; list argument in fn call
    (paren-wrap (comma-join (map to-sql x)))
    :else
    ;; alias
    (do
      (assert (= 2 (count x)) (str "Alias should have two parts" x))
      (let [[target alias] x]
        (str (to-sql target)
             ; Omit AS in FROM, JOIN, etc. - Oracle doesn't allow it
             (if (= :select *clause*) " AS " " ")
             (if (or (string? alias) (keyword? alias) (symbol? alias))
               (quote-identifier alias :split false)
               (binding [*subquery?* false]
                 (to-sql alias))))))))

(extend-protocol types/Inlinable
  #?(:clj clojure.lang.Keyword
     :cljs cljs.core/Keyword)
  (inline-str [x]
    (name x))
  nil
  (inline-str [_]
    "NULL")
  #?(:clj Object :cljs default)
  (inline-str [x]
    (str x)))

(extend-protocol ToSql
  #?(:clj clojure.lang.Keyword
     :cljs cljs.core/Keyword)
  (to-sql [x]
    (let [s (name x)]
      (case (.charAt s 0)
        \% (let [call-args (string/split (subs s 1) #"\." 2)]
             (to-sql (apply call (map keyword call-args))))
        \? (to-sql (param (keyword (subs s 1))))
        (quote-identifier x))))
  #?(:clj clojure.lang.Symbol
     :cljs cljs.core/Symbol)
  (to-sql [x] (quote-identifier x))
  #?(:clj java.lang.Boolean :cljs boolean)
  (to-sql [x]
    (if x "TRUE" "FALSE"))
  #?@(:clj
       [clojure.lang.Sequential
        (to-sql [x] (seq->sql x))])
  SqlCall
  (to-sql [x]
    (binding [*fn-context?* true]
       (let [fn-name (name (.-name x))
             fn-name (fn-aliases fn-name fn-name)]
         (apply fn-handler fn-name (.-args x)))))
  SqlRaw
  (to-sql [x]
    (let [s (.-s x)]
      (if (vector? s)
        (string/join "" (map (fn [x] (if (string? x) x (to-sql x))) s))
        s)))
  #?(:clj clojure.lang.IPersistentMap
     :cljs cljs.core/PersistentArrayMap)
  (to-sql [x]
    (map->sql x))
  #?(:clj clojure.lang.IPersistentSet
     :cljs cljs.core/PersistentHashSet)
  (to-sql [x]
    (to-sql (seq x)))
  nil
  (to-sql [x] "NULL")
  SqlParam
  (to-sql [x]
    (let [pname (param-name x)]
      (if (map? @*input-params*)
        (add-param pname (get @*input-params* pname))
        (let [x (first @*input-params*)]
          (swap! *input-params* rest)
          (add-param pname x)))))
  SqlArray
  (to-sql [x]
    (str "ARRAY[" (comma-join (map to-sql (.-values x))) "]"))
  SqlInline
  (to-sql [x]
    (inline-str (.-value x)))
  #?(:clj Object :cljs default)
  (to-sql [x]
    #?(:clj (add-anon-param x)
       :cljs (if (sequential? x)
               (seq->sql x)
               (add-anon-param x))))
  #?@(:cljs
       [cljs.core/PersistentHashMap
        (to-sql [x] (map->sql x))]))

(defn sqlable? [x]
  (satisfies? ToSql x))

;;;;

(defn format-predicate* [pred]
  (if-not (sequential? pred)
    (to-sql pred)
    (let [[op & args] pred
          op-name (name op)]
      (case op-name
        "not" (str "NOT " (format-predicate* (first args)))

        ("and" "or" "xor")
        (->> args
             (remove nil?)
             (map format-predicate*)
             (string/join (str " " (upper-case op-name) " "))
             (paren-wrap))

        "exists"
        (str "EXISTS " (to-sql (first args)))

        (to-sql (apply call pred))))))

(defn format-predicate
  "Formats a predicate (e.g., for WHERE, JOIN, or HAVING) as a string."
  [pred & {:keys [quoting parameterizer]
           :or {parameterizer :jdbc}}]
  (binding [*params* (atom [])
            *param-counter* (atom 0)
            *param-names* (atom [])
            *quote-identifier-fn* (or (quote-fns quoting)
                                      *quote-identifier-fn*)
            *parameterizer* parameterizer]
    (let [sql-str (format-predicate* pred)]
      (if (seq @*params*)
        (into [sql-str] @*params*)
        [sql-str]))))

(defmulti format-clause
  "Takes a map entry representing a clause and returns an SQL string"
  (fn [clause _] (key clause)))

(defn- -format-clause
  [clause _]
  (binding [*clause* (key clause)]
    (format-clause clause _)))

(defmethod format-clause :default [& _]
  "")

(defmethod format-clause :exists [[_ table-expr] _]
  (str "EXISTS " (to-sql table-expr)))

(defmulti format-modifiers (fn [[op & _]] op))

(defmethod format-modifiers :distinct [_] "DISTINCT")

(defmethod format-modifiers :default [coll]
  (space-join (map (comp upper-case name) coll)))

(defmethod format-clause :select [[_ fields] sql-map]
  (str "SELECT "
       (when (:modifiers sql-map)
         (str (format-modifiers (:modifiers sql-map)) " "))
       (comma-join (map to-sql fields))))

(defmethod format-clause :from [[_ tables] _]
  (str "FROM " (comma-join (map to-sql tables))))

(defmethod format-clause :where [[_ pred] _]
  (str "WHERE " (format-predicate* pred)))

(defn format-join [type table pred]
  (str (when type
         (str (upper-case (name type)) " "))
       "JOIN " (to-sql table)
       (when (some? pred)
         (if (and (sequential? pred) (= :using (first pred)))
           (str " USING (" (->> pred rest (map quote-identifier) comma-join) ")")
           (str " ON " (format-predicate* pred))))))

(defmethod format-clause :join [[_ join-groups] _]
  (space-join (map #(apply format-join :inner %)
                   (partition 2 join-groups))))

(defmethod format-clause :left-join [[_ join-groups] _]
  (space-join (map #(apply format-join :left %)
                   (partition 2 join-groups))))

(defmethod format-clause :right-join [[_ join-groups] _]
  (space-join (map #(apply format-join :right %)
                   (partition 2 join-groups))))

(defmethod format-clause :full-join [[_ join-groups] _]
  (space-join (map #(apply format-join :full %)
                   (partition 2 join-groups))))

(defmethod format-clause :cross-join [[_ join-groups] _]
  (space-join (map #(format-join :cross % nil) join-groups)))

(defmethod format-clause :group-by [[_ fields] _]
  (str "GROUP BY " (comma-join (map to-sql fields))))

(defmethod format-clause :having [[_ pred] _]
  (str "HAVING " (format-predicate* pred)))

(defmethod format-clause :order-by [[_ fields] _]
  (str "ORDER BY "
       (comma-join (for [field fields]
                     (if (sequential? field)
                       (let [[field & modifiers] field]
                         (string/join " "
                                      (cons (to-sql field)
                                            (for [modifier modifiers]
                                              (case modifier
                                                :desc "DESC"
                                                :asc "ASC"
                                                :nulls-first "NULLS FIRST"
                                                :nulls-last "NULLS LAST"
                                                "")))))
                       (to-sql field))))))

(defmethod format-clause :limit [[_ limit] _]
  (str "LIMIT " (to-sql limit)))

(defmethod format-clause :offset [[_ offset] _]
  (str "OFFSET " (to-sql offset)))

(defmulti format-lock-clause identity)

(defmethod format-lock-clause :update [_]
  "FOR UPDATE")

(defmethod format-lock-clause :mysql-share [_]
  "LOCK IN SHARE MODE")

(defmethod format-lock-clause :postgresql-share [_]
  "FOR SHARE")

(defmethod format-clause :lock [[_ lock] _]
  (let [{:keys [mode wait]} lock
        clause (format-lock-clause mode)]
    (str clause (when (false? wait) " NOWAIT"))))

(defmethod format-clause :insert-into [[_ table] _]
  (if (and (sequential? table) (sequential? (first table)))
    (str "INSERT INTO "
         (to-sql (ffirst table))
         (binding [*namespace-as-table?* false]
           (str " (" (comma-join (map to-sql (second (first table)))) ") "))
         (binding [*subquery?* false]
           (to-sql (second table))))
    (str "INSERT INTO " (to-sql table))))

(defmethod format-clause :columns [[_ fields] _]
  (binding [*namespace-as-table?* false]
    (str "(" (comma-join (map to-sql fields)) ")")))

(defmethod format-clause :composite [[_ fields] _]
  (comma-join (map to-sql fields)))

(defmethod format-clause :values [[_ values] _]
  (if (sequential? (first values))
    (str "VALUES " (comma-join (for [x values]
                                 (str "(" (comma-join (map to-sql x)) ")"))))
    (let [cols (keys (first values))]
      (str
       (binding [*namespace-as-table?* false]
         (str "(" (comma-join (map to-sql cols)) ")"))
       " VALUES "
       (comma-join (for [x values]
                     (str "(" (comma-join (map #(to-sql (get x %)) cols)) ")")))))))

(defmethod format-clause :query-values [[_ query-values] _]
  (to-sql query-values))

(defmethod format-clause :update [[_ table] _]
  (str "UPDATE " (to-sql table)))

(defmethod format-clause :set [[_ values] _]
  (str "SET " (comma-join (for [[k v] values]
                            (str (to-sql k) " = " (to-sql v))))))

(defmethod format-clause :set0 [[_ values] _]
  (str "SET " (comma-join (for [[k v] values]
                            (str (to-sql k) " = " (to-sql v))))))

(defmethod format-clause :set1 [[_ values] _]
  (str "SET " (comma-join (for [[k v] values]
                            (str (to-sql k) " = " (to-sql v))))))

(defmethod format-clause :delete-from [[_ table] _]
  (str "DELETE FROM " (to-sql table)))

(defmethod format-clause :delete [[_ tables] _]
  (str "DELETE " (comma-join (map to-sql tables))))

(defmethod format-clause :truncate [[_ table] _]
  (str "TRUNCATE " (to-sql table)))

(defn cte->sql
  [[cte-name query]]
  (str (binding [*subquery?* false]
         (to-sql cte-name))
       " AS "
       (to-sql query)))

(defmethod format-clause :with [[_ ctes] _]
  (str "WITH " (comma-join (map cte->sql ctes))))

(defmethod format-clause :with-recursive [[_ ctes] _]
  (str "WITH RECURSIVE " (comma-join (map cte->sql ctes))))

(defmethod format-clause :union [[_ maps] _]
  (binding [*subquery?* false]
    (string/join " UNION " (map to-sql maps))))

(defmethod format-clause :union-all [[_ maps] _]
  (binding [*subquery?* false]
    (string/join " UNION ALL " (map to-sql maps))))

(defmethod format-clause :intersect [[_ maps] _]
  (binding [*subquery?* false]
    (string/join " INTERSECT " (map to-sql maps))))

(defmethod format-clause :except [[_ maps] _]
  (binding [*subquery?* false]
    (string/join " EXCEPT " (map to-sql maps))))

(defmethod fn-handler "case" [_ & clauses]
  (str "CASE "
       (space-join
        (for [[condition result] (partition 2 clauses)]
          (if (= :else condition)
            (str "ELSE " (to-sql result))
            (let [pred (format-predicate* condition)]
              (str "WHEN " pred " THEN " (to-sql result))))))
       " END"))

(defn regularize [sql-string]
  (string/replace sql-string #"\s+" " "))
(ns honeysql.core
  (:refer-clojure :exclude [group-by format])
  (:require [honeysql.format :as format]
            [honeysql.types :as types]
            [honeysql.helpers :refer [build-clause]]
            #?(:clj [honeysql.util :refer [defalias]])
            [clojure.string :as string]))

(#?(:clj defalias :cljs def) call types/call)
(#?(:clj defalias :cljs def) raw types/raw)
(#?(:clj defalias :cljs def) param types/param)
(#?(:clj defalias :cljs def) inline types/inline)
(#?(:clj defalias :cljs def) format format/format)
(#?(:clj defalias :cljs def) format-predicate format/format-predicate)
(#?(:clj defalias :cljs def) quote-identifier format/quote-identifier)

(defn qualify
  "Takes one or more keyword or string qualifers and name. Returns
  a keyword of the concatenated qualifiers and name separated by periods.

  (qualify :foo \"bar\" :baz) => :foo.bar.baz"
  [& qualifiers+name]
  (keyword
   (string/join "."
     (for [s qualifiers+name
           :when (not (nil? s))]
       (if (keyword? s)
         (name s)
         (str s))))))

(defn build
  "Takes a series of clause+data pairs and returns a SQL map. Example:

      (build :select [:a :b]
             :from :bar)

  Clauses are defined with the honeysql.helpers/build-clause multimethod.
  Built-in clauses include:

      :select, :merge-select, :un-select
      :from, :merge-from
      :join, :merge-join
      :left-join, :merge-left-join
      :right-join, :merge-right-join
      :full-join, :merge-full-join
      :cross-join, :merge-cross-join
      :where, :merge-where
      :group-by, :merge-group-by
      :having, :merge-having
      :limit
      :offset
      :modifiers, :merge-modifiers
      :insert-into
      :columns, :merge-columns
      :values, :merge-values
      :query-values
      :update
      :set
      :delete-from"
  [& clauses]
  (let [[base clauses] (if (map? (first clauses))
                         [(first clauses) (rest clauses)]
                         [{} clauses])]
    (reduce
     (fn [sql-map [op args]]
       (build-clause op sql-map args))
     (if (empty? base)
       base
       (apply build (apply concat base)))
     (partition 2 clauses))))
(babashka.pods/load-pod 'org.babashka/go-sqlite3 "0.1.0" '{:download-only nil, :cache true})
(ns flights.db
  (:require [pod.babashka.go-sqlite3 :as sqlite]
            [honeysql.core :as sql]
            [flights.fuzzy :as fz]
            [clojure.string :as str]))

(def db "db/global_airports_sqlite.db")
           
(defn- make-query-space [db]
  (reduce (fn [q-space entry]
            (let [{:keys [name city country]} entry]
              (when name
                (assoc q-space
                       (str/join " " [name city country]) ;; presuming each query is unique
                       {:name name
                        :city city
                        :country country}))))

          {}
          (sqlite/query db ["Select name, city, country from airports"])))

(defn- suggest-match [query candidates]
  (let [[best-match cooef]
        (->>
         (reduce (fn [results candidate]
                   (assoc results candidate
                          (fz/coefficient query candidate)))
                 {}
                 candidates)
         (sort-by val)
         (reverse)
         first)]
    (when (pos? cooef)
      best-match)))

(defn snake->kebab
  "Very loose function, used becase of known snake-case values in source data."
  [key]
  (let [name (name key)]
    (->
     (str/replace name "_" "-")
     keyword)))

(defn transform-keys-to-kebab-case
  "For the sake of consistency in api outputs."
  [m]
  (let [ks (map snake->kebab (keys m))]
    (zipmap ks (vals m))))


(defn get-data-by-query [db query]
  (let [lookup              (make-query-space db)
        match               (->> (keys lookup)
                                 (remove #(re-find #"N/A" %)) ;; Filtering out :name with "N/A", since these appear to have 0,0 as lat/lng
                                 (suggest-match query))
        {:keys [name city country]} (lookup match)
        q                   (sql/format
                             {:select [:name :city :country :lat_decimal :lon_decimal]
                              :from   [:airports]
                              :where  [:and
                                       [:= :name name]
                                       [:= :city city]
                                       [:= :country country]]})]
    (-> (sqlite/query db q)
        first
        transform-keys-to-kebab-case)))

(defn airports-by-city-name [db city-query]
  (let [candidates (map :city (sqlite/query db "Select city from airports"))
        city       (suggest-match city-query candidates)
        query      (sql/format
                    {:select [:name]
                     :from   [:airports]
                     :where  [:and [:= :city city] [:not= :name "N/A"]]})]
    {:city city
     :airports
     (->> (sqlite/query db query)
          (mapv (comp str/capitalize :name)))}))

(defn cities-by-country-name [db country-query]
  (let [candidates (map :country (sqlite/query db "Select country from airports"))
        country    (suggest-match country-query candidates)
        query      (sql/format
                    {:select [:city]
                     :from   [:airports]
                     :where  [:and [:= :country country] [:not= :name "N/A"]]})]
    {:country country
     :cities
     (->> (sqlite/query db query)
          (mapv (comp str/capitalize :city)))}))


(def query-find (partial get-data-by-query db))

(def query-airports (partial airports-by-city-name db))

(def query-cities (partial cities-by-country-name db))
(ns flights.distance
  (:require [flights.carbon :as carbon]))

;; Calculating Distance between lat and lon

;; Earth's redius - 6,371km
(def R 6371e3)

(def rad-v (/ Math/PI 180))
;; Using this as a guide - https://www.movable-type.co.uk/scripts/latlong.html
(defn calculate-distance [lat1 lon1 lat2 lon2]
  (let [l1 (* lat1 rad-v)
        l2 (* lat2 rad-v)
        dlat (* (- lat2 lat1) rad-v)
        dlon (* (- lon2 lon1) rad-v)
        a (+ (Math/pow (Math/sin (/ dlat 2)) 2)
             (* (Math/cos l1)
                (Math/cos l2)
                (Math/pow (Math/sin (/ dlon 2)) 2)))
        c (* 2 (Math/atan2 (Math/sqrt a) (Math/sqrt (- 1 a))))]
    (* R c)))

(defn distance [location1 location2]
  (let [lat1 (:lat-decimal location1)
        lon1 (:lon-decimal location1)
        lat2 (:lat-decimal location2)
        lon2 (:lon-decimal location2)]
    (calculate-distance lat1 lon1 lat2 lon2)))


;; Average Air speed - 880–926 km/h
;; Average Air speed - 885-965 km/h
;; But, some distance is covered in take-off and landing and would need
;; to be factored in here ...
;; So, randomly reduced a little
(def air-speed [740 850])

(def take-off-and-landing-time 0.5)

(defn generate-flight-data [loc1 loc2]
  (let [distance         (-> (distance loc1 loc2)
                             (/ 1000)
                             float)
        co2-em           (carbon/personal-co2-emissions distance)
        diff-recommended (- co2-em carbon/recommended-annual-avg)]
    {:origin                     loc1
     :destination                loc2
     :co2-personal               (int co2-em)
     :co2-percentage-annual-avg  (int (* 100 (/ co2-em carbon/avg-person-annual-emissions)))
     :co2-difference-recommended diff-recommended
     :distance                   distance
     :flight-time                (map #(+ (/ distance %) take-off-and-landing-time)
                                      (reverse air-speed))}))
(ns flights.core
  (:require [flights.distance :as distance]
            [flights.db :as db]
            [flights.message :as message]
            [clojure.string :as str]
            [cheshire.core :as json]
            [babashka.cli :as cli]))

(defn flight-data-message [{:keys [distance] :as data}]
  (let [loc-msg      (message/oirgin-and-destination-msg data)
        distance-msg (str "Approximate Distance: " (int distance) " km")
        time-msg     (message/flight-time-msg data)
        carbon-msg   (message/carbon-msg data)]
    (str "-------------------------------------------------------------------\n"
         (str/join "\n\n"
                   [loc-msg
                    distance-msg
                    time-msg
                    carbon-msg])
         "\n-------------------------------------------------------------------")))

(defn cities-data [query]
  (db/query-cities query))

(defn airports-data [query]
  (db/query-airports query))

(defn flight-data [queries]
  (let [[q1 q2] queries
        [loc1 loc2] (map db/query-find queries)]
    (if (and loc1 loc2)
      (distance/generate-flight-data loc1 loc2)
      (println (str "Not Found: " (if loc1 q2 q1))))))

(defn flight-message [queries]
  (flight-data-message (flight-data queries)))

(def spec {:airports {:ref   "<city>"
                      :desc  "Lookup airports based on <city> query"
                      :alias :a}
           :cities   {:ref   "<country>"
                      :desc  "Lookup cities that have airports based on <country> query"
                      :alias :c}
           :data     {:ref "<format>"
                      :desc  "Optional flag to return any of the above as data <format>, either edn or json"
                      :coerce :keyword
                      :alias :d}
           :help     {:desc "Print this help message"
                      :alias :h}})
;; CLI Handling
(def help
  (str "To use, provide an <origin> and a <destination>.\n\n"
       "For example: flights 'new york' 'paris'\n\n"
       "Alternatively, search for airport and city names: \n"
       (cli/format-opts {:spec spec})
       "\n\nExample: flights -a 'New York' (returns list of new york airports)\n"
       "Example: flights -d json 'new york' 'paris' (returns flight info in json format)\n"
       "Example: flights -d edn -c 'germany' (returns cities in Germany in edn format)"))

(defn handle-data-format [fmt data]
  (case fmt
    :edn data
    :json (json/generate-string data)
    (println "Not a valid data format, please use either :json or :edn")))

(defn handle-opts [opts args]
  (cond
    (:cities opts)   (let [cities (cities-data (:cities opts))
                           data   (:data opts)]
                       (if data
                         (println (handle-data-format data cities))
                         (println (message/city-names-msg cities))))
    (:airports opts) (let [airports (airports-data (:airports opts))
                           data     (:data opts)]
                       (if data
                         (println (handle-data-format data airports))
                         (println (message/airport-names-msg airports))))
    (:data opts)     (let [fmt (:data opts)
                           data (flight-data (:args args))]
                       (println (handle-data-format fmt data)))
    :else            "Nothing happened..."))

(defn -main [input]
  (if (empty? input) (println help)
      (let [opts (cli/parse-opts input {:spec spec})
            args (cli/parse-args input)]
        (cond
          (seq opts)                    (handle-opts opts args)
          (not= (count (:args args)) 2) (println (str "Please provide an origin and a destination.\n"))
          :else                         (println (flight-message (:args args)))))))

;; Init function
(-main *command-line-args*)
